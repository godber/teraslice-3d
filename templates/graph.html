<!DOCTYPE html>
<html>
<head>
  <style> body { margin: 0; } </style>
  <script src="/static/3d-force-graph.js"></script>
  <script type="module">
    import { GUI } from '/static/lil-gui.esm.js';

    const elem = document.getElementById('3d-graph');

    // Color configuration object
    const colors = {
      kafkaIncoming: '#ffff00',  // yellow
      kafkaOther: '#0000ff',     // blue
      elasticsearch: '#00ff00'   // green
    };

    // Store original graph data for filtering
    let originalData = null;

    // Initialize graph without data first
    const Graph = new ForceGraph3D(elem)
      .nodeColor(node => {
        if (node.id.startsWith("kafka")) {
          if (node.id.includes("incoming")) {
            return colors.kafkaIncoming;
          }
          return colors.kafkaOther;
        } else {
          return colors.elasticsearch;
        }
      })
      .nodeLabel(node => `${node.id}`)
      .linkLabel(link => `${link.name} - ${link.workers} workers - ${link.status}`)
      // Dynamically scale linkWidth based on workers
      .linkWidth(link => {
        // scaled = ((original - min) / (max - min)) * (newMax - newMin) + newMin
        const newSize = ((link.workers - 1) / (200 - 1)) * (20 - 1) + 1
        return newSize
      })
      .linkColor(link => {
        if (link.status == 'running') return 'green'
        else if (link.status == 'starting') return 'palegreen'
        else if (link.status == 'stopped') return 'yellow'
        else if (link.status == 'stopping') return 'orange'
        else if (link.status == 'failing') return 'red'
      })
      .onLinkClick(link => window.open(`${link.url}`, '_blank'))

    // Initialize lil-gui controls
    const gui = new GUI({title: "Teraslice 3D Graph Controls"});
    const colorFolder = gui.addFolder('Node Colors');

    // Function to update node colors (works with filtered data)
    function updateNodeColors() {
      Graph.nodeColor(node => {
        if (node.id.startsWith("kafka")) {
          if (node.id.includes("incoming")) {
            return colors.kafkaIncoming;
          }
          return colors.kafkaOther;
        } else {
          return colors.elasticsearch;
        }
      });
    }

    colorFolder.addColor(colors, 'kafkaIncoming').name('Kafka Incoming').onChange(updateNodeColors);
    colorFolder.addColor(colors, 'kafkaOther').name('Kafka Other').onChange(updateNodeColors);
    colorFolder.addColor(colors, 'elasticsearch').name('Elasticsearch').onChange(updateNodeColors);

    colorFolder.open();

    // Add filtering controls
    const filterFolder = gui.addFolder('Filtering');
    const filterState = { 
      nodeSearchTerm: '',
      linkSearchTerm: ''
    };

    const nodeSearchController = filterFolder.add(filterState, 'nodeSearchTerm').name('Search Nodes').onChange(value => {
      filterGraphData(value, filterState.linkSearchTerm);
    });

    const linkSearchController = filterFolder.add(filterState, 'linkSearchTerm').name('Search Links').onChange(value => {
      filterGraphData(filterState.nodeSearchTerm, value);
    });

    filterFolder.add({ 
      clear: () => {
        filterState.nodeSearchTerm = '';
        filterState.linkSearchTerm = '';
        filterGraphData('', '');
        nodeSearchController.updateDisplay();
        linkSearchController.updateDisplay();
      }
    }, 'clear').name('Clear All Filters');

    filterFolder.open();

    // Load graph data and initialize
    async function loadGraphData() {
      try {
        originalData = await fetch('/pipeline_graph').then(r => r.json());
        Graph.graphData(originalData);
      } catch (error) {
        console.error('Error loading graph data:', error);
      }
    }

    // Filter function for graph data
    function filterGraphData(nodeSearchTerm = '', linkSearchTerm = '') {
      if (!originalData) return;
      
      if (!nodeSearchTerm && !linkSearchTerm) {
        Graph.graphData(originalData);
        return;
      }

      // Filter nodes if node search term is provided
      let filteredNodes = originalData.nodes;
      if (nodeSearchTerm) {
        filteredNodes = originalData.nodes.filter(node =>
          node.id.toLowerCase().includes(nodeSearchTerm.toLowerCase())
        );
      }

      // Filter links based on link search term and remaining nodes
      let filteredLinks = originalData.links;
      
      // First filter by link search term if provided
      if (linkSearchTerm) {
        filteredLinks = originalData.links.filter(link =>
          link.name.toLowerCase().includes(linkSearchTerm.toLowerCase())
        );
      }

      // Then ensure we only keep links between remaining nodes
      const nodeIds = new Set(filteredNodes.map(n => n.id));
      filteredLinks = filteredLinks.filter(link => {
        // Handle both string IDs and object references
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        return nodeIds.has(sourceId) && nodeIds.has(targetId);
      });

      // If we're filtering by links, we also need to include nodes that are connected by the filtered links
      if (linkSearchTerm && !nodeSearchTerm) {
        const linkedNodeIds = new Set();
        filteredLinks.forEach(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;
          linkedNodeIds.add(sourceId);
          linkedNodeIds.add(targetId);
        });
        filteredNodes = originalData.nodes.filter(node => linkedNodeIds.has(node.id));
      }

      Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
    }

    // Load data when page loads
    loadGraphData();
  </script>
</head>
<body>
  <div id="3d-graph"></div>
</body>
</html>
