<!DOCTYPE html>
<html>
<head>
  <style> body { margin: 0; } </style>
  <script src="/static/3d-force-graph.js"></script>
  <script src="https://unpkg.com/three@0.168.0/build/three.min.js"></script>
  <script type="module">
    import { GUI } from '/static/lil-gui.esm.js';

    const elem = document.getElementById('3d-graph');

    // Color configuration object
    const colors = {
      kafkaIncoming: '#ffff00',  // yellow
      kafkaOther: '#0000ff',     // blue
      elasticsearch: '#00ff00'   // green
    };

    // Store original graph data for filtering
    let originalData = null;
    
    // Post-processing setup
    let outlinePass = null;

    // Initialize graph without data first
    const Graph = new ForceGraph3D(elem)
      .nodeColor(node => {
        if (node.id.startsWith("kafka")) {
          if (node.id.includes("incoming")) {
            return colors.kafkaIncoming;
          }
          return colors.kafkaOther;
        } else {
          return colors.elasticsearch;
        }
      })
      .nodeLabel(node => `${node.id}`)
      .linkLabel(link => `${link.name} - ${link.workers} workers - ${link.status}`)
      // Dynamically scale linkWidth based on workers
      .linkWidth(link => {
        // scaled = ((original - min) / (max - min)) * (newMax - newMin) + newMin
        const newSize = ((link.workers - 1) / (200 - 1)) * (20 - 1) + 1
        return newSize
      })
      .linkColor(link => {
        if (link.status == 'running') return 'green'
        else if (link.status == 'starting') return 'palegreen'
        else if (link.status == 'stopped') return 'yellow'
        else if (link.status == 'stopping') return 'orange'
        else if (link.status == 'failing') return 'red'
      })
      .onLinkClick(link => window.open(`${link.url}`, '_blank'))

    // Set up post-processing after graph initialization
    async function setupPostProcessing() {
      // Check if THREE is available
      if (typeof THREE === 'undefined') {
        console.warn('THREE.js not loaded yet, retrying...');
        setTimeout(setupPostProcessing, 100);
        return;
      }
      
      try {
        // Dynamically import the post-processing modules
        const { EffectComposer } = await import('https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js');
        const { RenderPass } = await import('https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/RenderPass.js');
        const { OutlinePass } = await import('https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/OutlinePass.js');
        
        const scene = Graph.scene();
        const camera = Graph.camera();
        const renderer = Graph.renderer();
        
        // Create composer manually since we need to use the imported classes
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        outlinePass = new OutlinePass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          scene,
          camera
        );
        
        // Configure outline appearance
        outlinePass.edgeStrength = 3.0;
        outlinePass.edgeGlow = 0.5;
        outlinePass.edgeThickness = 1.0;
        outlinePass.visibleEdgeColor.set('#00ffff'); // cyan
        outlinePass.hiddenEdgeColor.set('#0000ff'); // blue
        
        composer.addPass(outlinePass);
        
        // Replace the graph's composer with our custom one
        Graph.postProcessingComposer(composer);
        
        console.log('Post-processing setup complete');
      } catch (error) {
        console.error('Failed to load post-processing modules:', error);
      }
    }

    // Initialize lil-gui controls
    const gui = new GUI({title: "Teraslice 3D Graph Controls"});
    const colorFolder = gui.addFolder('Node Colors');

    // Function to update node colors (works with filtered data)
    function updateNodeColors() {
      Graph.nodeColor(node => {
        if (node.id.startsWith("kafka")) {
          if (node.id.includes("incoming")) {
            return colors.kafkaIncoming;
          }
          return colors.kafkaOther;
        } else {
          return colors.elasticsearch;
        }
      });
    }

    colorFolder.addColor(colors, 'kafkaIncoming').name('Kafka Incoming').onChange(updateNodeColors);
    colorFolder.addColor(colors, 'kafkaOther').name('Kafka Other').onChange(updateNodeColors);
    colorFolder.addColor(colors, 'elasticsearch').name('Elasticsearch').onChange(updateNodeColors);

    colorFolder.open();

    // Add filtering controls
    const filterFolder = gui.addFolder('Filtering');
    const filterState = { 
      nodeSearchTerm: '',
      linkSearchTerm: '',
      filterMode: 'Remove'
    };
    
    // Add filter mode dropdown
    const filterModeController = filterFolder.add(filterState, 'filterMode', ['Remove', 'Highlight']).name('Filter Mode').onChange(value => {
      filterGraphData(filterState.nodeSearchTerm, filterState.linkSearchTerm);
    });

    const nodeSearchController = filterFolder.add(filterState, 'nodeSearchTerm').name('Search Nodes').onChange(value => {
      filterGraphData(value, filterState.linkSearchTerm);
    });

    const linkSearchController = filterFolder.add(filterState, 'linkSearchTerm').name('Search Links').onChange(value => {
      filterGraphData(filterState.nodeSearchTerm, value);
    });

    filterFolder.add({ 
      clear: () => {
        filterState.nodeSearchTerm = '';
        filterState.linkSearchTerm = '';
        filterGraphData('', '');
        nodeSearchController.updateDisplay();
        linkSearchController.updateDisplay();
      }
    }, 'clear').name('Clear All Filters');

    filterFolder.open();

    // Load graph data and initialize
    async function loadGraphData() {
      try {
        originalData = await fetch('/pipeline_graph').then(r => r.json());
        Graph.graphData(originalData);
        
        // Set up post-processing after graph is loaded
        setTimeout(() => {
          setupPostProcessing();
        }, 500);
      } catch (error) {
        console.error('Error loading graph data:', error);
      }
    }

    // Filter function for graph data
    function filterGraphData(nodeSearchTerm = '', linkSearchTerm = '') {
      if (!originalData) return;
      
      if (filterState.filterMode === 'Highlight') {
        filterGraphDataHighlight(nodeSearchTerm, linkSearchTerm);
      } else {
        filterGraphDataRemove(nodeSearchTerm, linkSearchTerm);
      }
    }

    // Original remove-based filtering
    function filterGraphDataRemove(nodeSearchTerm = '', linkSearchTerm = '') {
      // Clear any outline highlighting
      if (outlinePass) {
        outlinePass.selectedObjects = [];
      }
      
      if (!nodeSearchTerm && !linkSearchTerm) {
        Graph.graphData(originalData);
        return;
      }

      // Filter nodes if node search term is provided
      let filteredNodes = originalData.nodes;
      if (nodeSearchTerm) {
        filteredNodes = originalData.nodes.filter(node =>
          node.id.toLowerCase().includes(nodeSearchTerm.toLowerCase())
        );
      }

      // Filter links based on link search term and remaining nodes
      let filteredLinks = originalData.links;
      
      // First filter by link search term if provided
      if (linkSearchTerm) {
        filteredLinks = originalData.links.filter(link =>
          link.name.toLowerCase().includes(linkSearchTerm.toLowerCase())
        );
      }

      // Then ensure we only keep links between remaining nodes
      const nodeIds = new Set(filteredNodes.map(n => n.id));
      filteredLinks = filteredLinks.filter(link => {
        // Handle both string IDs and object references
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        return nodeIds.has(sourceId) && nodeIds.has(targetId);
      });

      // If we're filtering by links, we also need to include nodes that are connected by the filtered links
      if (linkSearchTerm && !nodeSearchTerm) {
        const linkedNodeIds = new Set();
        filteredLinks.forEach(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;
          linkedNodeIds.add(sourceId);
          linkedNodeIds.add(targetId);
        });
        filteredNodes = originalData.nodes.filter(node => linkedNodeIds.has(node.id));
      }

      Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
    }

    // New highlight-based filtering using OutlinePass
    function filterGraphDataHighlight(nodeSearchTerm = '', linkSearchTerm = '') {
      // Always show all data in highlight mode
      Graph.graphData(originalData);
      
      if (!outlinePass) return;
      
      if (!nodeSearchTerm && !linkSearchTerm) {
        outlinePass.selectedObjects = [];
        return;
      }

      // Find matching nodes and their corresponding 3D objects
      const matchingNodeIds = new Set();
      
      // Filter nodes if node search term is provided
      if (nodeSearchTerm) {
        originalData.nodes.forEach(node => {
          if (node.id.toLowerCase().includes(nodeSearchTerm.toLowerCase())) {
            matchingNodeIds.add(node.id);
          }
        });
      }
      
      // Filter by links and include connected nodes
      if (linkSearchTerm) {
        const matchingLinks = originalData.links.filter(link =>
          link.name.toLowerCase().includes(linkSearchTerm.toLowerCase())
        );
        
        matchingLinks.forEach(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;
          matchingNodeIds.add(sourceId);
          matchingNodeIds.add(targetId);
        });
      }
      
      // Get 3D objects for matching nodes
      const selectedObjects = [];
      const scene = Graph.scene();
      
      scene.traverse((object) => {
        if (object.userData && object.userData.__graphObjType === 'node') {
          const nodeData = object.userData.__data;
          if (nodeData && matchingNodeIds.has(nodeData.id)) {
            selectedObjects.push(object);
          }
        }
      });
      
      outlinePass.selectedObjects = selectedObjects;
    }

    // Load data when page loads
    loadGraphData();
  </script>
</head>
<body>
  <div id="3d-graph"></div>
</body>
</html>
